
///////////////////////////////////////////////////////////////////////////////
// store 'xor' ////////////////////////////////////////////////////////////////

#nomodmsf inline fn __update_ptr_xor_ref(
  reg u64 output plain len,
  inline int n)
  ->
  reg u64,
  reg u64,
  reg u64
{
  output += n;
  plain += n;
  len -= n;
  return output, plain, len;
}

// 64 bytes
#nomodmsf inline fn __store_xor_ref(
  stack u64 s_output s_plain s_len,
  reg u32[16] k,
  stack u32 k14 k15,
  #msf reg u64 ms)
->
  stack u64,
  stack u64,
  stack u64
{
  inline int i;
  reg u64[8] kk;
  reg u64 output plain len;
  reg u64 aux;

  // i = 0 : 1 dead
  kk[0] = (64u) k[1];
  kk[0] <<= 32;
  aux = (64u)k[0];
  kk[0] ^= aux;

  //plain = s_plain;
  plain = s_plain;
  plain = #protect(plain, ms);

  kk[0] ^= (u64)[plain + 8*0];

  // i = 1 : 2 dead
  kk[1] = (64u) k[3];
  kk[1] <<= 32;
  aux = (64u)k[2];
  kk[1] ^= aux;
  kk[1] ^= (u64)[plain + 8*1];

  //output = s_output;
  output = s_output;
  output = #protect(output, ms);

  (u64)[output + 8*0] = kk[0];

  for i=2 to 8
  {
    kk[i] = (64u)((i == 7) ? k15 : k[2*i+1]);
    kk[i] <<= 32;
    aux = (64u)((i == 7) ? k14 : k[2*i]);
    kk[i] ^= aux;
    kk[i] ^= (u64)[plain + 8*i];
    (u64)[output + 8*(i-1)] = kk[i-1];
  }

  (u64)[output + 8*7] = kk[7];

  //len = s_len;
  len = s_len;
  len = #protect(len, ms);

  output, plain, len = __update_ptr_xor_ref(output, plain, len, 64);

  s_output = output;
  s_plain = plain;
  s_len = len;

  return s_output, s_plain, s_len;
}

#nomodmsf inline fn __sum_states_store_xor_ref(
  stack u64 s_output s_plain s_len,
  reg u32[16] k,
  stack u32 k14 k15,
  stack u32[16] st,
  #msf reg u64 ms
) ->
  stack u64,
  stack u64,
  stack u64
{
  inline int i;
  reg u64[8] kk;
  reg u64 output plain len;
  reg u64 aux;

  // store                        // sum states
  // i = 0 : 1 dead
                                  k[1] += st[1];
                                  k[0] += st[0];
  kk[0] = (64u) k[1];
  kk[0] <<= 32;
  aux = (64u)k[0];
  kk[0] ^= aux;

  //plain = s_plain;
  plain = s_plain;
  plain = #protect(plain, ms);


  kk[0] ^= (u64)[plain + 8*0];

  // i = 1 : 2 dead
                                  k[3] += st[3];
                                  k[2] += st[2];
  kk[1] = (64u) k[3];
  kk[1] <<= 32;
  aux = (64u)k[2];
  kk[1] ^= aux;
  kk[1] ^= (u64)[plain + 8*1];

  //output = s_output;
  output = s_output;
<<<<<<< Updated upstream
  output = #protect(output, ms);

=======
  stack u32 k14;
  k14 = k[14];
  len = s_len;
  
>>>>>>> Stashed changes
  (u64)[output + 8*0] = kk[0];

  for i=2 to 8
  {
<<<<<<< Updated upstream
                                  k[2*i+1] = k15 if (2*i+1 == 15);
                                  k[2*i] = k14 if (2*i == 14);
                                  k[2*i+1] += st[2*i+1];
                                  k[2*i] += st[2*i];
=======
                                                  if (2*i+1 == 15) { k[2*i+1] = k15; k[2 * i] = k14; }
                                                  k[2*i+1] += st[2*i+1];
                                                  k[2*i] += st[2*i];
>>>>>>> Stashed changes
    kk[i] = (64u)(k[2*i+1]);
    kk[i] <<= 32;
    aux = (64u)k[2*i];
    kk[i] ^= aux;
    kk[i] ^= (u64)[plain + 8*i];
    (u64)[output + 8*(i-1)] = kk[i-1];
  }

  (u64)[output + 8*7] = kk[7];

<<<<<<< Updated upstream
  //len = s_len;
  len = s_len;
  len = #protect(len, ms);
=======
>>>>>>> Stashed changes

  output, plain, len = __update_ptr_xor_ref(output, plain, len, 64);

  s_output = output;
  s_plain = plain;
  s_len = len;

  return s_output, s_plain, s_len;
}

inline fn __store_xor_last_ref(
  stack u64 s_output s_plain s_len,
  reg u32[16] k,
  stack u32 k14 k15,
  #msf reg u64 ms)
  ->
  #msf reg u64
{
  inline int i;
  reg u64 j output plain len len8;
  reg u64 t;
  reg u32 u;
  stack u32[16] s_k;
  reg u8 pi;
  reg bool b;

  s_k[0] = k[0];
  s_k[1] = k[1];
  s_k[2] = k[2];

  output = s_output;
  plain = s_plain;
  len = s_len;

  // copy k to stack
<<<<<<< Updated upstream
  for i=0 to 14
=======
  for i=3 to 15
>>>>>>> Stashed changes
  { s_k[i] = k[i]; }

  u = k14;
  s_k[14] = u;

  u = k15;
  s_k[15] = u;

<<<<<<< Updated upstream
  //output = s_output;
  output = s_output;
  output = #protect(output, ms);

  //plain = s_plain;
  plain = s_plain;
  plain = #protect(plain, ms);

  //len = s_len;
  len = s_len;
  len = #protect(len, ms);

=======
>>>>>>> Stashed changes

  // u64 at a time
  len8 = len;
  len8 >>= 3;
  j = 0;
  while {
    b = (j < len8);
  }(b)
  {
    ms = #set_msf(b, ms);
    t = (u64)[plain + 8*j];
    t ^= s_k[u64 (int)j];
    (u64)[output + 8*j] = t;
    j += 1;
  }
  ms = #set_msf(!b, ms);
  j <<= 3;

  // u8 at a time
  while {
    b = (j < len);
  }(b)
  {
    ms = #set_msf(b, ms);
    pi = (u8)[plain + j];
    pi ^= s_k[u8 (int)j];
    (u8)[output + j] = pi;
    j += 1;
  }
  ms = #set_msf(!b, ms);

  return ms;
}

///////////////////////////////////////////////////////////////////////////////
// store //////////////////////////////////////////////////////////////////////

#nomodmsf inline fn __update_ptr_ref(
  reg u64 output len,
  inline int n)
  ->
  reg u64,
  reg u64
{
  output += n;
  len -= n;
  return output, len;
}

// 64 bytes
#nomodmsf inline fn __store_ref(
  stack u64 s_output s_len,
  reg u32[16] k,
  stack u32 k14 k15,
  #msf reg u64 ms)
  ->
  stack u64,
  stack u64
{
  inline int i;
  reg u64[8] kk;
  reg u64 output len;
  reg u64 aux;

  // i = 0 : 1 dead
  kk[0] = (64u) k[1];
  kk[0] <<= 32;
  aux = (64u)k[0];
  kk[0] ^= aux;

  // i = 1 : 2 dead
  kk[1] = (64u) k[3];
  kk[1] <<= 32;
  aux = (64u)k[2];
  kk[1] ^= aux;

  //output = s_output;
  output = s_output;
  output = #protect(output, ms);

  (u64)[output + 8*0] = kk[0];

  for i=2 to 8
  {
    kk[i] = (64u)((i == 7) ? k15 : k[2*i+1]);
    kk[i] <<= 32;
    aux = (64u)((i == 7) ? k14 : k[2*i]);
    kk[i] ^= aux;
    (u64)[output + 8*(i-1)] = kk[i-1];
  }

  (u64)[output + 8*7] = kk[7];

  //len = s_len;
  len = s_len;
  len = #protect(len, ms);

  output, len = __update_ptr_ref(output, len, 64);

  s_output = output;
  s_len = len;

  return s_output, s_len;
}

#nomodmsf inline fn __sum_states_store_ref(
  stack u64 s_output s_len,
  reg u32[16] k,
  stack u32 k14 k15,
  stack u32[16] st,
  #msf reg u64 ms)
  ->
  stack u64,
  stack u64
{
  inline int i;
  reg u64[8] kk;
  reg u64 output len;
  reg u64 aux;

  // store                        // sum states
  // i = 0 : 1 dead
                                  k[1] += st[1];
                                  k[0] += st[0];
  kk[0] = (64u) k[1];
  kk[0] <<= 32;
  aux = (64u)k[0];
  kk[0] ^= aux;

  // i = 1 : 2 dead
                                  k[3] += st[3];
                                  k[2] += st[2];
  kk[1] = (64u) k[3];
  kk[1] <<= 32;
  aux = (64u)k[2];
  kk[1] ^= aux;

  //output = s_output;
  output = s_output;
<<<<<<< Updated upstream
  output = #protect(output, ms);

=======
  stack u32 k14;
  k14 = k[14];
  len = s_len;
>>>>>>> Stashed changes
  (u64)[output + 8*0] = kk[0];

  for i=2 to 8
  {
<<<<<<< Updated upstream
                                  k[2*i+1] = k15 if (2*i+1 == 15);
                                  k[2*i] = k14 if (2*i == 14);
                                  k[2*i+1] += st[2*i+1];
                                  k[2*i] += st[2*i];
=======
                                                  if (2*i+1 == 15) { k[2*i+1] = k15; k[2*i] = k14; }
                                                  k[2*i+1] += st[2*i+1];
                                                  k[2*i] += st[2*i];
>>>>>>> Stashed changes
    kk[i] = (64u)(k[2*i+1]);
    kk[i] <<= 32;
    aux = (64u)k[2*i];
    kk[i] ^= aux;
    (u64)[output + 8*(i-1)] = kk[i-1];
  }

  (u64)[output + 8*7] = kk[7];

<<<<<<< Updated upstream
  //len = s_len;
  len = s_len;
  len = #protect(len, ms);

=======
>>>>>>> Stashed changes
  output, len = __update_ptr_ref(output, len, 64);

  s_output = output;
  s_len = len;

  return s_output, s_len;
}

inline fn __store_last_ref(
  stack u64 s_output s_len,
  reg u32[16] k,
  stack u32 k14 k15,
  #msf reg u64 ms)
  ->
  #msf reg u64
{
  inline int i;
  reg u64 j output len len8;
  reg u64 t;
  reg u32 u;
  stack u32[16] s_k;
  reg u8 pi;
  reg bool b;

  s_k[0] = k[0];
  s_k[1] = k[1];

  output = s_output;
  len = s_len;

  // copy k to stack
<<<<<<< Updated upstream
  for i=0 to 14
=======
  for i=2 to 15
>>>>>>> Stashed changes
  { s_k[i] = k[i]; }

  u = k14;
  s_k[14] = u;

  u = k15;
  s_k[15] = u;

<<<<<<< Updated upstream
  //output = s_output;
  output = s_output;
  output = #protect(output, ms);

  //len = s_len;
  len = s_len;
  len = #protect(len, ms);


=======
>>>>>>> Stashed changes
  // u64 at a time
  len8 = len;
  len8 >>= 3;
  j = 0;
  while {
    b = (j < len8);
  }(b)
  {
    ms = #set_msf(b, ms);
    t = s_k[u64 (int)j];
    (u64)[output + 8*j] = t;
    j += 1;
  }
  ms = #set_msf(!b, ms);
  j <<= 3;

  // u8 at a time
  while {
    b = (j < len);
  }(b)
  {
    ms = #set_msf(b, ms);
    pi = s_k[u8 (int)j];
    (u8)[output + j] = pi;
    j += 1;
  }
  ms = #set_msf(!b, ms);

  return ms;
}
