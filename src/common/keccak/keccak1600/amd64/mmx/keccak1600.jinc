param int KECCAK_ROUNDS=24;

require "keccakf1600.jinc"

inline fn __keccak_init_mmx() -> stack u64[25]
{
  stack u64[25] state;
  reg u64 i t;

  _,_,_,_,_, t = #set0();
  i = 0;
  while (i < 25)
  { state[(int)i] = t;
    i += 1;
  }

  return state;
}


inline fn __add_full_block_mmx(
  stack u64[25] state,
  reg u64 in inlen,
  reg u64 rate
) -> stack u64[25], reg u64, reg u64
{
  reg u64 i t rate64;

  rate64 = rate;
  rate64 >>= 3;
  i = 0;
  while( i < rate64)
  {
    t = [in + 8*i];
    state[(int)i] ^= t;
    i+=1;
  }

  in += rate;
  inlen -= rate;

  return state, in, inlen;
}


// obs: @pre: inlen < rate_in_bytes
inline fn __add_final_block_mmx(
  stack u64[25] state,
  reg   u64 in inlen,
  reg   u8  trail_byte,
  reg   u64 rate
) -> stack u64[25]
{
  reg u64 i t inlen8;
  reg u8 c;

  inlen8 = inlen;
  inlen8 >>= 3;
  i = 0;
  while ( i < inlen8 )
  {
    t = [in + 8*i];
    state[(int)i] ^= t;
    i += 1;
  }

  i <<= 3;
  while ( i < inlen )
  {
    c = (u8)[in + i];
    state[u8 (int)i] ^= c;
    i += 1;
  }

  state[u8 (int)i] ^= trail_byte;

  i = rate;
  i -= 1;
  state[u8 (int)i] ^= 0x80;

  return state;
}


inline fn __absorb_mmx(
  stack u64[25] state,
  reg   u64 in inlen,
  stack u8  s_trail_byte,
  reg   u64 rate // rate already in bytes -- it is returned bc of spills
) -> stack u64[25], reg u64
{
  regx u64 x_in x_inlen x_rate;
  reg u8 trail_byte;
  reg u64 t;

  // intermediate blocks
  while ( inlen >= rate )
  {
    state, in, inlen = __add_full_block_mmx(state, in, inlen, rate);
    x_in = #MOVX(in);
    x_inlen = #MOVX(inlen);
    x_rate = #MOVX(rate);

    state = __keccakf1600_mmx(state);
    in = #MOVX(x_in);
    inlen = #MOVX(x_inlen);
    rate = #MOVX(x_rate);
  }

  // final block
  trail_byte = s_trail_byte;

  state = __add_final_block_mmx(state, in, inlen, trail_byte, rate);

  return state, rate;
}


inline fn __xtr_full_block_mmx(
  stack u64[25] state,
  reg u64 out outlen,
  reg u64 rate
) -> reg u64, reg u64
{
  reg u64 i t rate64;

  rate64 = rate;
  rate64 >>= 3;
  i = 0;
  while ( i < rate64 )
  {
    t = state[(int)i];
    [out + 8*i] = t;
    i += 1;
  }

  out += rate;
  outlen -= rate;

  return out, outlen;
}


inline fn __xtr_bytes_mmx(
  stack u64[25] state,
  reg u64 out outlen
) -> reg u64
{
  reg u64 i t outlen8;
  reg u8 c;

  outlen8 = outlen;
  outlen8 >>= 3;
  i = 0;
  while ( i < outlen8 )
  {
    t = state[(int)i];
    [out + 8*i] = t;
    i += 1;
  }
  i <<= 3;

  while ( i < outlen )
  {
    c = state[u8 (int)i];
    (u8)[out + i] = c;
    i += 1;
  }

  out += outlen;
  return out;
}


inline fn __squeeze_mmx(
  stack u64[25] state,
  regx u64 x_out,
  reg   u64 outlen,
  reg   u64 rate
)
{
  reg u64 out;
  regx u64 x_outlen x_rate;

  // intermediate blocks
  while ( outlen > rate )
  {
    x_outlen = #MOVX(outlen);
    x_rate = #MOVX(rate);
    state = __keccakf1600_mmx(state);
    out = #MOVX(x_out);
    outlen = #MOVX(x_outlen);
    rate = #MOVX(x_rate);

    out, outlen = __xtr_full_block_mmx(state, out, outlen, rate);
    x_out = #MOVX(out);
  }

  x_outlen = #MOVX(outlen);
  state = __keccakf1600_mmx(state);
  out = #MOVX(x_out);
  outlen = #MOVX(x_outlen);

  out = __xtr_bytes_mmx(state, out, outlen);
}


inline fn __keccak1600_mmx(reg u64 out outlen in inlen, reg u8 trail_byte, reg u64 rate)
{
  stack u64[25] state;
  regx u64 x_out x_outlen;
  stack u8 s_trail_byte;

  x_out = #MOVX(out);
  x_outlen = #MOVX(outlen);
  s_trail_byte = trail_byte;

  state = __keccak_init_mmx();

  // absorb
  state, rate = __absorb_mmx(state, in, inlen, s_trail_byte, rate);

  // squeeze
  outlen = #MOVX(x_outlen);
  __squeeze_mmx(state, x_out, outlen, rate);
}


fn _keccak1600_mmx(reg u64 out outlen in inlen, reg u8 trail_byte, reg u64 rate)
{
  __keccak1600_mmx(out, outlen, in, inlen, trail_byte, rate);
}
